export const cheatSheetsData = {
    "Java Core": [
        { name: "Encapsulation", desc: "Data hiding by making fields private and using public getters/setters.", details: ["Improves security by restricting direct access to fields.", "Allows validation logic in setters (e.g., age > 0).", "Makes the code more maintainable: you can change internal logic without affecting callers.", "Known as 'Data Hiding' and is the fundamental building block of OOP.", "Protects the integrity of an object's internal state."], syntax: "public class User {\n  private String name;\n  \n  public String getName() { return name; }\n  public void setName(String n) { \n    if(n != null) this.name = n; \n  }\n}" },
        { name: "Inheritance", desc: "Acquiring properties of a parent class using 'extends' for reuse.", details: ["Supports the 'is-a' relationship (e.g., Dog is an Animal).", "Facilitates code reusability and method overriding.", "Java does not support multiple inheritance with classes to avoid 'Diamond Problem'.", "Achieved using the 'extends' keyword for classes and 'implements' for interfaces.", "Private members of parent are NOT inherited directly."], syntax: "class Animal { void eat() { } }\nclass Dog extends Animal {\n  @Override\n  void eat() { super.eat(); }\n}" },
        { name: "Polymorphism", desc: "One interface, many forms (Overloading vs Overriding).", details: ["Static Polymorphism: Method Overloading (same name, different signature) at compile-time.", "Dynamic Polymorphism: Method Overriding (same name/signature) at runtime.", "Allows objects of different classes to be treated as objects of a common superclass.", "Implicit casting to parent type (Upcasting) is automatic.", "Key for designing flexible frameworks."], syntax: "// Overriding\n@Override\npublic void draw() { ... }\n\n// Overloading\nvoid add(int a) { }\nvoid add(int a, int b) { }" },
        { name: "Abstraction", desc: "Hiding implementation details using Abstract Classes or Interfaces.", details: ["Focuses on 'what' an object does instead of 'how' it does it.", "Abstract classes can have both abstract (bodyless) and concrete (regular) methods.", "Interfaces provide structural contracts (100% abstract before Java 8).", "Cannot create instances (objects) of an abstract class or interface directly.", "Enforces a template for all subclasses."], syntax: "abstract class Shape {\n  abstract void draw();\n}\n\ninterface Drawable {\n  void render();\n}" },
        { name: "Interface vs Abstract Class", desc: "Interfaces: Multi-inheritance, Abstract Class: Shared state.", details: ["Interfaces support multiple inheritance; Abstract classes do not.", "Interfaces cannot have state (variables), only constants; Abstract classes can have instance variables.", "Abstract classes can have constructors; Interfaces cannot (prior to Java 8/9).", "Interfaces use 'implements'; Classes use 'extends'.", "Interfaces are for defining capabilities (Flyable); Abstract for base identity (Bird)."], syntax: "interface Flyable { void fly(); }\nabstract class Bird { String species; }" },
        { name: "Access Modifiers", desc: "Public, Private, Protected, and Default modifiers.", details: ["Private: Accessible only within the same class (maximum encapsulation).", "Default: Accessible within the same package (package-private).", "Protected: Same package + subclasses in other packages.", "Public: Accessible from anywhere in the project.", "Standard practice: Private fields, Public methods."], syntax: "private int id;\npublic String name;\nprotected double salary;\nint age; // default" },
        { name: "Static Keyword", desc: "Belongs to the class, not an object.", details: ["Static variables: Only one copy exists in memory, shared by all objects.", "Static methods: Can be called without creating an instance.", "Static block: Used for initializing static variables when class is loaded.", "Static methods cannot access non-static instance fields directly.", "Main method is static because JVM calls it before any objects exist."], syntax: "static int count = 0;\nstatic void display() {\n  System.out.println(count);\n}" },
        { name: "Final Keyword", desc: "Used to make constants, prevent override, or prevent inheritance.", details: ["Final Variable: Becomes a constant (value cannot be changed).", "Final Method: Cannot be overridden by any subclass.", "Final Class: Cannot be extended/inherited (e.g., String class).", "Final Parameter: Value cannot be modified inside the method.", "Blank final variables must be initialized in the constructor."], syntax: "final double PI = 3.14;\nfinal void lock() { }\nfinal class Sealed { }" },
        { name: "Super vs This", desc: "Super: Parent class ref, This: Current class ref.", details: ["this: Refers to the current instance of the class.", "super: Refers to the immediate parent class instance/members.", "this(): Invokes another constructor in the same class.", "super(): Invokes parent class constructor (must be the first line).", "Usually used to resolve ambiguity between instance fields and local parameters."], syntax: "this.name = name;\nsuper.eat();\nsuper(); // constructor call" },
        { name: "String Immutability", desc: "Once created, value cannot change. Uses String Constant Pool.", details: ["Security: Critical for passing passwords or DB URLs.", "Caching: Hashcode is cached, making String key lookup fast in Maps.", "String Constant Pool (SCP): Saves heap memory by sharing identical literals.", "Thread-safety: Multiple threads can share a string without synchronization.", "Operations like concat() create a NEW string object."], syntax: "String s1 = \"Hello\";\ns1.concat(\" World\");\nSystem.out.println(s1); // still \"Hello\"" },
        { name: "StringBuilder vs StringBuffer", desc: "Builder: Fast/Non-thread-safe, Buffer: Slow/Thread-safe.", details: ["StringBuilder: Best for single-threaded string manipulations.", "StringBuffer: Synchronized methods, thread-safe but slower performance.", "Both are mutable (can modify existing text without creating new objects).", "Capacity: Both manage an internal buffer that expands automatically.", "Common methods: append(), insert(), reverse(), delete()."], syntax: "StringBuilder sb = new StringBuilder();\nsb.append(\"Dev\").append(\"Ready\");" },
        { name: "Exception Hierarchy", desc: "Throwable -> Exception and Error.", details: ["Checked: Checked at compile-time (e.g., IOException, SQLException).", "Unchecked: Happens at runtime (e.g., NullPointerException, ArithmeticException).", "Error: Non-recoverable problems (e.g., OutOfMemory, StackOverflow).", "Throw: Used to explicitly trigger an exception.", "Throws: Declares that a method might throw certain exceptions."], syntax: "try { throw new Exception(); }\ncatch(Exception e) { }" },
        { name: "Try-Catch-Finally", desc: "Standard structure for exception handling and cleanup.", details: ["Try: Code that might fail goes here.", "Catch: Code to handle the specific failure.", "Finally: Runs NO MATTER WHAT (even if return is called in try/catch).", "Used for critical resource cleanup (closing DB connections).", "A try block must be followed by at least one catch or finally."], syntax: "try { ... } \ncatch(Exception e) { ... } \nfinally { /* cleanup */ }" },
        { name: "JVM Architecture", desc: "Classloader, Runtime Data, Execution Engine.", details: ["Classloader: Loads .class files into the Runtime areas.", "Heap: Stores all objects; shared among all threads.", "Stack: Stores temporary local variables; private to each thread.", "JIT Compiler: Optimizes hot code segments into native machine code.", "Garbage Collector (GC): Periodically frees memory from unreachable objects."], syntax: "Runtime = Heap + Stack + MethodArea + PC" },
        { name: "Heap vs Stack", desc: "Heap: Global storage, Stack: Execution storage.", details: ["Stack memory is small/fixed; Heap is large/resizable.", "Stack is LIFO (First-in Last-out); Heap has random access.", "Objects live on the Heap; References (pointers) live on the Stack.", "Stack is cleared automatically when method exits; Heap needs GC.", "Variables on stack cannot be shared between threads."], syntax: "User u = new User(); // ref on stack, data on heap" },
        { name: "Garbage Collection", desc: "Automatic memory management system.", details: ["Unreachable objects are marked for deletion by the GC daemon thread.", "Mark and Sweep: Marks live objects, deletes others.", "Generational GC: Young Generation, Old Generation, Metaspace.", "System.gc() only requests collection; JVM might ignore it.", "Minor GC (Young Gen) is frequent; Major/Full GC (Old Gen) is slow."], syntax: "finalize() // called before object is erased" },
        { name: "ArrayList vs LinkedList", desc: "Dynamic Array vs Doubly Linked Nodes.", details: ["ArrayList: Fast random access (O(1)). Bad for inserts at start (O(N)).", "LinkedList: Fast inserts/deletes anywhere (O(1)) if pointer is known.", "ArrayList is more memory efficient (compact).", "LinkedList nodes use extra memory for 'next' and 'prev' pointers.", "Conclusion: Use ArrayList for searching, LinkedList for large edits."], syntax: "List<String> list = new ArrayList<>();" },
        { name: "HashSet vs TreeSet", desc: "Unique items vs Sorted unique items.", details: ["HashSet: No duplicates, NO order, O(1) performance.", "TreeSet: No duplicates, SORTED order, O(log N) performance.", "HashSet is faster but doesn't guarantee sequence.", "TreeSet uses a Red-Black Tree internally.", "HashSet uses high-speed hashing internally."], syntax: "Set<Integer> set = new HashSet<>();" },
        { name: "HashMap Internal", desc: "How HashMap stores keys and values.", details: ["Uses an array of 'Buckets'. Index = hash(key) % array_length.", "Collision: When two keys get the same index (stored in a list).", "Java 8: If a list becomes > 8 nodes, it turns into a balanced Tree.", "Load Factor (0.75): HashMap resizes when 75% full.", "Initial Capacity: Default is 16."], syntax: "map.put(key, val); // hash -> bucket -> store" },
        { name: "ConcurrentHashMap", desc: "Thread-safe high-performance Map.", details: ["Unlike Hashtable, it doesn't lock the whole map.", "Locks happen at the bucket/node level (Segment locking in early Java).", "Reads are non-blocking; multiple writes can happen in different buckets.", "Null keys or values are NOT permitted.", "Much faster than Collections.synchronizedMap(hashmap)."], syntax: "Map<K,V> map = new ConcurrentHashMap<>();" },
        { name: "Generics", desc: "Type safety for classes and methods.", details: ["Prevents Runtime ClassCastExceptions by checking types at compile-time.", "Example: List<String> can only hold strings.", "Type Erasure: JVM removes generics after compilation for compatibility.", "Generics only work with Reference types (not primitives like int).", "Can use wildcards like <? extends Number>."], syntax: "List<Integer> list = new ArrayList<>();" },
        { name: "Lambda Expressions", desc: "Pass code logic as a parameter.", details: ["Functional Programming:Treating methods as first-class citizens.", "Removes the need for bulky Anonymous classes.", "Works with @FunctionalInterface (interfaces with 1 method).", "Concise syntax: (args) -> { body }.", "Access variables from outer scope (effectively final)."], syntax: "list.forEach(item -> System.out.println(item));" },
        { name: "Stream API", desc: "Modern way to process collections.", details: ["Pipelining: Chaining multiple operations (filter, map, sorted).", "Lazy Evaluation: Nothing happens until a Terminal operation is called.", "Intermediate: filter(), map(), flatMap(), distinct().", "Terminal: collect(), count(), forEach(), reduce().", "Doesn't modify original data; produces a new result."], syntax: "results = data.stream().filter(x -> x > 5).toList();" },
        { name: "Thread Creation", desc: "Ways to run code in parallel.", details: ["Method 1: Extend the Thread class (Direct).", "Method 2: Implement the Runnable interface (Flexible).", "Always call .start() not .run() (run executes on same thread).", "Threads allow multi-tasking and non-blocking UIs.", "Modern way: Use ExecutorService and Thread Pools."], syntax: "new Thread(() -> System.out.println(\"Hi\")).start();" },
        { name: "Synchronized", desc: "Prevents multiple threads from accessing code together.", details: ["Guarantees that only one thread executes a block/method at a time.", "Solves Race Conditions (data corruption during simultaneous edits).", "Synchronized methods lock the 'this' object.", "Static synchronized locks the Class object.", "Blocks are better than methods as they lock only specific lines."], syntax: "synchronized(lock) { /* sensitive code */ }" },
        { name: "Volatile", desc: "Ensures variable visibility across threads.", details: ["Forces the CPU to read/write from RAM instead of its local Cache.", "Ensures thread A sees changes made by thread B immediately.", "Used for 'Flags' (like while(keepRunning)).", "Does NOT guarantee atomicity (use AtomicInt for counter++).", "Lightweight compared to synchronized."], syntax: "private volatile boolean active = true;" },
        { name: "Optional Class", desc: "Container to prevent NullPointerExceptions.", details: ["Wrap a value that might be null: Optional.ofNullable(val).", "Forces developer to handle the 'missing' case.", "Methods: ifPresent(), orElse(), flatMap(), map().", "Better than checking if (val != null) everywhere.", "Introduced in Java 8."], syntax: "Optional.ofNullable(user).map(User::getName).orElse(\"NA\");" },
        { name: "Reflection API", desc: "Inspect and modify classes at runtime.", details: ["Allows access to private methods/fields without permission.", "Can instantiate classes dynamically using String names.", "Used by frameworks like Spring and Hibernate for 'magic' DI.", "Warning: Slower performance and potential security risks.", "Break encapsulation only when absolutely necessary (e.g., testing)."], syntax: "Method m = cls.getDeclaredMethod(\"secret\");\nm.setAccessible(true);\nm.invoke(obj);" },
        { name: "Serialization", desc: "Saving objects to disk or network.", details: ["Converts an object's state into a byte stream (.ser file).", "Class must implement 'Serializable' marker interface.", "serialVersionUID is used to verify version compatibility.", "Static and Transient variables are NOT serialized.", "Crucial for distributed systems and RMI (Remote Method Invocation)."], syntax: "FileOutputStream f = new FileOutputStream(\"file\");\nObjectOutputStream out = new ObjectOutputStream(f);\nout.writeObject(obj);" },
        { name: "Functional Interfaces", desc: "Interfaces with one abstract method.", details: ["Used as the base for Lambda expressions.", "@FunctionalInterface annotation is optional but recommended.", "Can have multiple static or default methods.", "Common examples: Predicate, Function, Consumer, Supplier.", "Predicate<T> takes T and returns boolean."], syntax: "@FunctionalInterface\ninterface Calculator {\n  int compute(int x, int y);\n}" },
        { name: "Method References", desc: "Shorthand for simple Lambdas.", details: ["Syntax uses double colons (::).", "Static Method Ref: Class::staticMethod.", "Instance Method Ref: instance::methodName.", "Constructor Ref: ClassName::new.", "Cleanest way to pass existing methods as logic."], syntax: "list.forEach(System.out::println);" },
        { name: "Default Methods", desc: "Adding behavior to interfaces.", details: ["Introduced in Java 8 for backward compatibility.", "Allows adding new methods to interfaces without breaking implementing classes.", "Can be overridden by the implementing class if needed.", "Enables 'Multiple Inheritance' of behavior (not state).", "Use 'default' keyword in interface."], syntax: "interface Loggable {\n  default void log() { System.out.println(\"Log\"); }\n}" },
        { name: "Annotations", desc: "Metadata for Java code.", details: ["Instruction for the compiler or runtime environment.", "@Override: Prevents accidental method name errors.", "@Deprecated: Warns that a method is old and should not be used.", "@SuppressWarnings: Tells compiler to ignore specific warnings.", "Can be custom-defined using @interface."], syntax: "@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface LogMe { }" },
        { name: "Enum Class", desc: "Fixed set of constants.", details: ["Stronger than basic constants (int/String).", "Can have fields, constructors, and methods.", "Implicitly extends java.lang.Enum.", "Perfect for Days of Week, Status codes, User Roles.", "Constructor is private by default."], syntax: "enum Status { \n  ACTIVE, INACTIVE; \n  void show() { ... } \n}" },
        { name: "Wrapper Classes", desc: "Primitives as objects.", details: ["Integer, Float, Double, Boolean, Character.", "Needed because Collections (ArrayList, etc.) only store Objects.", "Provides utility methods (Integer.parseInt, Long.toHexString).", "Autoboxing: Automatic conversion between int and Integer.", "Improves cross-platform compatibility."], syntax: "Integer n = 10; // Autoboxing\nint x = n; // Unboxing" }
    ],
    "Spring Boot": [
        { name: "Dependency Injection", desc: "Spring provides objects to your class instead of you creating them.", details: ["Loose Coupling: Your class doesn't need to know how to build its dependencies.", "Constructor Injection: Recommended by Spring (Final fields, mandatory deps).", "Setter Injection: Good for optional dependencies.", "Field Injection: Easiest (@Autowired private...) but bad for testing.", "Spring's IoC container manages the entire 'wiring' process."], syntax: "@Autowired\npublic MyService(MyRepo repo) { this.repo = repo; }" },
        { name: "Inversion of Control", desc: "The framework controls the flow, not your code.", details: ["Spring takes control of creating, configuring, and managing beans.", "Developers focus on 'what' to do (logic), Spring handles 'when' and 'how'.", "ApplicationContext is the main engine of IoC.", "Configuration can be Java-based (@Configuration) or XML-based.", "DI is the specific way IoC is implemented in Spring."], syntax: "Spring Context -> Manages lifecycle of beans" },
        { name: "@SpringBootApplication", desc: "The mega-annotation for every project.", details: ["Combines three annotations: @Configuration, @EnableAutoConfiguration, and @ComponentScan.", "@Configuration: Class is a source of bean definitions.", "@EnableAutoConfiguration: Guesses what you need based on JARs on classpath.", "@ComponentScan: Looks for @Component classes in the current package.", "Typically placed on the root package's Main class."], syntax: "@SpringBootApplication\npublic class App { ... }" },
        { name: "@RestController", desc: "Specialized controller for REST APIs.", details: ["Short version of @Controller + @ResponseBody on every method.", "Maps returned objects directly to JSON or XML for the browser.", "Eliminates the need for ViewResolvers (no HTML templates).", "Ideal for SPAs (React/Angular) and Mobile apps.", "Handles HTTP methods: GET, POST, PUT, DELETE, PATCH."], syntax: "@RestController\n@RequestMapping(\"/api\")\npublic class Controller { ... }" },
        { name: "Spring Data JPA", desc: "Effortless database management.", details: ["Reduces database boilerplate; no need to write SQL for simple tasks.", "Repository pattern: Just define an interface extending JpaRepository.", "Query creation: findByEmail(String email) generates SQL automatically.", "Supports Paging and Sorting out of the box.", "Uses Hibernate internally to map Java objects to database tables."], syntax: "public interface UserRepo extends JpaRepository<User, Long> { }" },
        { name: "@Transactional", desc: "Ensures DB operations are all-or-nothing.", details: ["Atomicity: If one part of the method fails, everything rolls back.", "Ensures data consistency across multiple database calls.", "Automatic rollback only on Unchecked Exceptions (RuntimeException).", "Can configure read-only, isolation levels, and propagation rules.", "Usually used at the Service layer."], syntax: "@Transactional\npublic void completePurchase() { ... }" },
        { name: "Spring Security", desc: "Standard framework for Auth and Protect.", details: ["Authentication: Verifies who you are (Username/Password, OAuth, JWT).", "Authorization: Verifies what you can do (Admin vs User roles).", "Protects against common attacks like CSRF and XSS.", "Filter-based architecture that intercepts every request.", "Method-level security with @PreAuthorize(\"hasRole('ADMIN')\")."], syntax: "http.authorizeRequests().anyRequest().authenticated();" },
        { name: "Beans & Scopes", desc: "Managing bean lifecycle and visibility.", details: ["Singleton: Default. One instance per Spring Container.", "Prototype: New instance every time it is requested.", "Request: One instance per HTTP request (Web only).", "Session: One instance per user session (Web only).", "Application: Scoped to the ServletContext."], syntax: "@Bean\n@Scope(\"prototype\")\npublic User user() { return new User(); }" },
        { name: "Spring Boot Actuator", desc: "Monitoring and managing your app. ", details: ["Provides built-in endpoints for health, metrics, and logs.", "/health: Tells you if the app and DB are running.", "/metrics: Shows CPU usage, memory, and HTTP traffic stats.", "/info: Displays custom app information.", "Crucial for production environments and dashboards."], syntax: "management.endpoints.web.exposure.include=health,info" },
        { name: "Auto-Configuration", desc: "Spring Boot's 'Magic' feature.", details: ["Looks at your 'pom.xml' and automatically configures beans.", "If 'H2' is in classpath, it configures an in-memory database.", "If 'spring-web' is there, it configures Tomcat and DispatcherServlet.", "Can be customized or disabled using excludes.", "Follows 'Opinionated' defaults to speed up development."], syntax: "// Automatic setup happens in the background" },
        { name: "Global Exception Handling", desc: "Centralized error management.", details: ["Using @ControllerAdvice to intercept exceptions project-wide.", "@ExceptionHandler: Defines how to handle a specific error type.", "Returns consistent JSON error responses: {status, message, path}.", "Avoids try-catch blocks in every controller method.", "Improves API reliability and developer experience."], syntax: "@ControllerAdvice\npublic class GlobalHandler {\n  @ExceptionHandler(UserNotFound.class)\n  public Response handle(UserNotFound ex) { ... }\n}" },
        { name: "Profiles", desc: "Environment-specific configurations.", details: ["Switch between Dev, Test, and Prod settings easily.", "Properties files: application-dev.properties, application-prod.properties.", "Active profile selected via spring.profiles.active property.", "Can mark specific Beans to only load in certain profiles (@Profile).", "Ensures correct DB URL and API keys in different environments."], syntax: "@Profile(\"prod\")\n@Bean\npublic DataSource db() { ... }" },
        { name: "@Value vs @ConfigurationProperties", desc: "Reading settings from files.", details: ["@Value: Good for a single property/environment variable.", "@ConfigurationProperties: Best for a group of related properties/nested objects.", "Supports 'Relaxed Binding' (camelCase vs kebab-case).", "Supports Validation (@NotNull, etc.).", "Ensures type safety when reading config."], syntax: "@Value(\"${app.name}\")\nprivate String n;\n\n@ConfigurationProperties(\"mail\")\npublic class Mail { ... }" },
        { name: "Spring Cloud Gateway", desc: "Request routing for Microservices.", details: ["Centralized entry point for all client requests.", "Filters: Can modify request/response (Add headers, Auth).", "Predicates: Logic to route to specific services based on path/host.", "Load Balancing: Integrates with Eureka/Consul.", "Rate Limiting: Built-in support to prevent API abuse."], syntax: "gate.route(\"r1\", r -> r.path(\"/u/**\").uri(\"lb://u-service\"))" },
        { name: "Eureka Service Discovery", desc: "Phonebook for microservices.", details: ["Registration: Services register their IP/Port on startup.", "Discovery: Clients fetch the registry to find service locations.", "Health Monitoring: Eureka removes crashed services from registry.", "Avoids hardcoding IPs in configurations.", "Crucial for scaling and dynamic cloud environments."], syntax: "@EnableEurekaServer\npublic class DiscoveryApp { ... }" },
        { name: "Feign Client", desc: "Declarative HTTP client.", details: ["Write HTTP calls by just defining an interface.", "Integrates with Load Balancer (Ribbon/LoadBalancer).", "Cleaner than using RestTemplate or WebClient.", "Supports Fallbacks (via Hystrix/Resilience4j).", "Auto-serializes JSON to POJOs."], syntax: "@FeignClient(name=\"auth\")\npublic interface AuthClient {\n  @GetMapping(\"/v\") boolean val();\n}" }
    ],
    "DSA": [
        { name: "Big O Notation", desc: "Measuring algorithmic efficiency.", details: ["Describes how Time or Space needs grow as input size (N) increases.", "O(1): constant time. Fastest. Index access.", "O(log N): Logarithmic. Very fast. Binary Search.", "O(N): Linear. Scales with input. Simple loops.", "O(N log N): Typical for good sorting (Merge/Quick sort).", "O(N^2): Quadratic. Slow. Nested loops."], syntax: "// Loop through N elements = O(N)" },
        { name: "Arrays", desc: "Fixed-size contiguous memory blocks.", details: ["Access: O(1) via index.", "Search: O(N) for unsorted, O(log N) for sorted.", "Insert/Delete: O(N) because elements must be shifted.", "Pros: Memory efficient, fast access.", "Cons: Fixed size, expensive resizing (needs new array creation)."], syntax: "int[] arr = {1, 2, 3};\nint val = arr[0]; // O(1)" },
        { name: "Binary Search", desc: "Efficient search in sorted arrays.", details: ["Condition: MUST be sorted.", "Logics: Always check the middle. Eliminate half the search space.", "Complexity: O(log N).", "Iterative or Recursive implementations.", "Used as a building block for complex search algorithms."], syntax: "mid = low + (high-low)/2;\nif(target < arr[mid]) high = mid - 1;" },
        { name: "Merge Sort", desc: "Stable Divide & Conquer sorting.", details: ["Divide-and-Conquer: Split array into half until 1 element remains.", "Merge: Re-combine pieces in sorted order into a temporary array.", "Time Complexity: O(N log N) - guaranteed (Worst/Best/Avg).", "Space Complexity: O(N) because of the temporary merging array.", "Stable: Maintains original order of equal elements (important for objects)."], syntax: "mergeSort(arr, l, r);\n// Logic: l -> mid, mid+1 -> r" },
        { name: "Quick Sort", desc: "In-place efficient sorting.", details: ["Pivot Selection: Pick a 'Pivot' element (Random, First, or Last).", "Partitioning: Move items < pivot to left, items > pivot to right.", "Recursion: Repeat for both partitions.", "Time Complexity: Avg O(N log N), Worst O(N^2) if pivot is extreme.", "Space Complexity: O(log N) for recursion stack; In-place data movement."], syntax: "pivot = arr[high];\npartition(arr, low, high);" },
        { name: "Dijkstra's Algorithm", desc: "Shortest path in weighted graph.", details: ["Greedy approach: Always picks the next closest 'undiscovered' node.", "Condition: Works only with non-negative edge weights.", "Data Structure: Uses a Priority Queue for finding minimum distance node.", "Time Complexity: O((V+E) log V) with Min-Priority-Queue.", "Used in Google Maps for route finding between locations."], syntax: "pq.add(new Pair(start, 0));\n// Update distances of neighbors" },
        { name: "Stack (LIFO)", desc: "Last-In, First-Out data structure.", details: ["Operations: Push (add), Pop (remove top), Peek (view top).", "Complexity: All operations are O(1).", "Used for: Undo/Redo, Function calls (Recursion), Balanced brackets.", "Can be implemented using Array or Linked List.", "Java provides java.util.Stack class."], syntax: "Stack<Integer> s = new Stack<>();\ns.push(10); s.pop();" },
        { name: "Queue (FIFO)", desc: "First-In, First-Out data structure.", details: ["Operations: Enqueue (add to back), Dequeue (remove from front).", "Complexity: All operations are O(1).", "Used for: Multi-tasking, Buffer systems, Printer queues, Graph BFS.", "Special types: Circular Queue, Priority Queue, Deque.", "Java uses Queue<T> q = new LinkedList<>();"], syntax: "q.add(val); q.poll();" },
        { name: "Dynamic Programming", desc: "Optimizing code by caching sub-results.", details: ["Overlapping Subproblems: Same math solved multiple times (Recursion).", "Optimal Substructure: Final answer can be built from small answers.", "Memoization: Top-down approach using Recursion + Cache (Map/Array).", "Tabulation: Bottom-up approach using Loops + DP Table.", "Common errors: 2^N (Normal) vs N (DP) for Fibonacci."], syntax: "if(memo.contains(x)) return memo[x];\nmemo[x] = solve(x-1) + solve(x-2);" },
        { name: "Hash Table Implementation", desc: "O(1) search and insert logic.", details: ["Hash Function: Converts Key into an Array Index.", "Collision: When different keys result in the same index.", "Chaining Strategy: Store a Linked List at that index.", "Open Addressing: Find next available slot (Linear Probing).", "Load Factor: Threshold to resize (usually 0.75 in Java)."], syntax: "index = hash(key) % capacity;" },
        { name: "Graph: BFS vs DFS", desc: "Traversal strategies for networks.", details: ["BFS: Level-order search using a Queue. Finds SHORTEST path in unweighted graph.", "DFS: Deep search using a Stack/Recursion. Good for cycle detection and paths.", "Complexity: Both are O(V + E).", "Topological Sort: Possible using modified DFS.", "Applications: Social networks (BFS), Maze solving (DFS)."], syntax: "// BFS: use q.poll(); q.add();\n// DFS: use visit(neighbor);" },
        { name: "Min/Max Heap", desc: "Efficient priority management.", details: ["Complete Binary Tree where Parent > Children (Max) or Parent < Children (Min).", "Root is ALWAYS the Max or Min element (O(1) access).", "Insertion: O(log N) as element bubbles up.", "Extraction: O(log N) as last element moves to root and bubbles down.", "Used in Priority Queues and HeapSort."], syntax: "heapifyUp(index);\nheapifyDown(index);" },
        { name: "Bit Manipulation", desc: "Extremely fast operations.", details: ["AND (&): Checks overlapping bits.", "OR (|): Joins bits.", "XOR (^): Checks differing bits. (a^a = 0).", "Shifts (<<, >>): Multiplies or Divides by 2 powers.", "Tricks: parity check (x & 1), toggling bits, fast math."], syntax: "isEven = (num & 1) == 0;\nclearBit = num & ~(1 << i);" },
        { name: "Sliding Window", desc: "O(N) trick for subarrays.", details: ["Avoids nested O(N^2) loops by maintaining a running window.", "Window expands from right and shrinks from left.", "Good for: Max sum subarray of size K, Longest distinct string.", "Maintains a constant or variable window of elements.", "One of the most common coding interview patterns."], syntax: "while(sum > cap) { sum -= arr[left++]; }" }
    ],
    "Sys Design": [
        { name: "Scalability: Horz vs Vert", desc: "How to handle more load.", details: ["Vertical: Adding more power (CPU/RAM) to one server (Scale UP). Limited capacity.", "Horizontal: Adding more servers to the cluster (Scale OUT). Infinite potential.", "Horizontal requires a Load Balancer.", "Vertical is easier but expensive and has a hardware ceiling.", "Most modern systems (FB, Google) use massive Horizontal scaling."], syntax: "Scale Up: upgraded 16GB -> 64GB RAM\nScale Out: 1 server -> 10 servers" },
        { name: "Load Balancer", desc: "Traffic policeman for your servers.", details: ["Positions: Sits between users and web servers.", "Algorithms: Round Robin, Least Connections, IP-Hash.", "Health Checks: Stops sending traffic if a server crashes.", "Terminates SSL connections to reduce load on backend servers.", "Software LBs: NGINX, HAProxy, AWS ELB."], syntax: "User -> Load Balancer -> [S1, S2, S3]" },
        { name: "Caching: Redis/Memcached", desc: "Temporary fast storage.", details: ["Why: Reading from RAM is 1000x faster than reading from DB (Disk).", "Cache Aside: Check cache -> If miss, get from DB -> Update cache.", "Expiration (TTL): Data is removed after social time to keep it fresh.", "Eviction: LRU (Least Recently Used) deletes old data when cache is full.", "Use cases: User sessions, top products, leaderboard scores."], syntax: "Data stored in Key-Value format in RAM" },
        { name: "CAP Theorem", desc: "The rules of distributed systems.", details: ["Consistency: Every node sees same data at same time.", "Availability: System is always up even if data is old.", "Partition Tolerance: System works even if some nodes can't talk.", "Rule: You can only pick TWO during a network failure.", "Relational DBs (SQL) = CA/CP; NoSQL (Cassandra/Dynamo) = AP."], syntax: "Pick 2: C-A, C-P, or A-P" },
        { name: "Database: SQL vs NoSQL", desc: "Structured vs Flexible data.", details: ["SQL (Postgres, MySQL): Tabular, ACID compliant, pre-defined schema. Relational.", "NoSQL (Mongo, Redis, Cassandra): Dynamic, horizontally scalable, high speed.", "NoSQL types: Document, Key-Value, Columnar, Graph.", "Use SQL for: Finances, Transactions, complex Joins.", "Use NoSQL for: Big data, Real-time apps, flexible profiles."], syntax: "SQL: SELECT * FROM users;\nNoSQL: db.users.find();" },
        { name: "Microservices", desc: "Small services instead of one Monolith.", details: ["Decoupling: Each team can work and deploy their service independently.", "Tech Agnostic: Auth service can be Java, Payment can be Go.", "Resilience: If 'Reviews' service fails, 'Ordering' can still work.", "Challenge: Complex dev-ops, data consistency, network latency.", "Communication: REST, gRPC, or Message Queues (Kafka)."], syntax: "Monolith [A+B+C] vs Micro [A] [B] [C]" },
        { name: "Message Queues: Kafka", desc: "Async communication for services.", details: ["Producer: Sends the message. Consumer: Processes it later.", "Decoupling: Producer doesn't wait for consumer to finish.", "Persistence: Messages are stored so they can be replayed if a service fails.", "Use cases: Order processing, Email alerts, Log aggregation.", "Tools: Apache Kafka, RabbitMQ, Amazon SQS."], syntax: "Producer -> Queue -> Consumer" },
        { name: "CDN (Content Delivery Network)", desc: "Global delivery for static assets.", details: ["Servers are placed worldwide (Edge Locations).", "Users get data (Images, CSS, JS) from the nearest location.", "Reduces Latency (speed) and saves original server bandwidth.", "Essential for high-traffic sites (Netflix, YouTube).", "Tools: Cloudflare, AWS CloudFront, Akamai."], syntax: "User in India -> Edge Server in Mumbai (not USA)" },
        { name: "Database Sharding", desc: "Splitting a giant database into smaller pieces.", details: ["Horizontal Sharding: Rows 1-1M on Server A, 1-2M on Server B.", "Allows one database to scale beyond the limits of a single machine.", "Shard Key: The variable used to split data (e.g., user_id).", "Challenge: Very hard to perform Joins across two different shards.", "Solution for multi-TB datasets."], syntax: "BigDB -> [Shard 1] [Shard 2] [Shard 3]" },
        { name: "Consistent Hashing", desc: "Hashing for distributed system scaling.", details: ["Solves the problem of high data movement during re-sharding.", "Servers and data are mapped to a Virtual Circle (Ring).", "Adding or removing a server only affects adjacent data in the ring.", "Used in Distributed Caching (Redis Cluster) and DynamoDB.", "Virtual Nodes ensure data is balanced even if servers have different power."], syntax: "Ring Circle -> Hash(Key) -> Clockwise Server" },
        { name: "Rate Limiting", desc: "Preventing API overload.", details: ["Limits the number of requests a user can make in a timeframe.", "Protects against DDoS attacks and brute force.", "Hard vs Soft limits: (e.g., 100/min).", "Algorithms: Leaky Bucket, Token Bucket, Fixed Window Counter.", "Usually implemented at the API Gateway level."], syntax: "if(count > max) return 429_TOO_MANY_REQUESTS;" },
        { name: "Circuit Breaker Pattern", desc: "Stopping the spread of errors.", details: ["Monitors remote calls; if failures cross a threshold, it 'trips' the circuit.", "Open: Requests fail immediately without calling the service.", "Half-Open: Slowly allows traffic to see if service recovered.", "Closed: Everything is OK, calls go through.", "Tooling: Resilience4j, Hystrix."], syntax: "@CircuitBreaker(name=\"pay\", fallback=\"error\")" },
        { name: "DNS (Domain Name System)", desc: "Phonebook of the Internet.", details: ["Translates Names (google.com) to IPs (142.250...).", "Highly distributed and hierarchical (Root -> TLD -> Authoritative).", "Caching: DNS results are cached at Browser, OS, and ISP levels.", "TTL (Time to Live): Determines how long a record is cached.", "A Record (IPv4), AAAA (IPv6), CNAME (Alias), MX (Mail)."], syntax: "google.com -> 142.250.xxx.xxx" },
        { name: "Heartbeat & Gossip", desc: "Checking system health.", details: ["Heartbeat: Regular signal sent to Load Balancer to prove 'liveness'.", "Gossip Protocol: Peers share information with each other like rumors.", "Used in decentralized systems (Cassandra) to sync state.", "Ensures cluster health without a single point of failure.", "Fast way to detect if a server has died."], syntax: "Status: [NodeA: Alive, NodeB: Dead]" }
    ]
};
